% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\usepackage{hyperref}
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%%% END Article customizations

%%% The "real" document content comes below...

\title{CMSC838L - Milestone 2}
\author{Yusuf Bham \\ Arjun Vedantham}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\section{Progress Updates}

Since the last milestone, we have been able to synthesize a basic Calyx program (loading a value into a 1D memory and representing that value using the built-in LEDs) into SystemVerilog. From here, we were able to use the sv2v parser to convert it into synthesizable Verilog, and deploy it to a Lattice Icestick FPGA. However, we are still debugging some elements of the physical implementation, particularly with handling the go/reset signaling that Calyx uses for organizing the schedule of actions in the sequential logic circuit. 

To ensure that we are still making progress towards building out our language, we have started to use the \href{https://docs.cocotb.org/en/stable/index.html}{cocotb} circuit testing framework, which can be used to generate unit tests for the circuits our DSL generates. Gonig forward, we plan on bridging the gap between our AST representation of the language with actual rewrite rules that can be used to synthesize Calyx from programs in our DSL. 

\section{Evaluation Plan}
We are working towards two potential evaluation plans. 

First, we would like to continue using the cocotb and Icarus Verilog simulators to verify the correctness of our DSL implementation. Given a starting set of values in the memory (Calyx provides a way to preload values into memories when running simulations), we plan on running basic operations (e.g. 1D convolution) across the set of operations and verifying using unit tests to ensure that the updated values are written out to memory correctly. We will also compare this against reference implementations in C/Python in terms of lines of code. 

Second, we would ideally deploy our programs to an actual FPGA. While we are still trying to debug some of the hardware issues that have come up with using the Lattice Icestick FPGA, we would like to use an Arduino to feed numbers (representing captured samples from say, an SDR) over a serial communication line, and have the circuit running on the Icestick respond with the result of the computation. However, we are not sure whether we would be able to ensure that this interface is fully working by the presentation due date, so we will prioritize using simulation to verify the correctness of our DSL. 

\end{document}
