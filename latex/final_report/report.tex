\documentclass[12pt]{article}
\usepackage{graphicx} % Required for inserting images
\usepackage[margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{minted}
\usepackage{xparse}
\usepackage{graphicx}
\usepackage[normalem]{ulem}
\usepackage{soul}
\usepackage{float}
\usepackage{hyperref}
\NewDocumentCommand{\codeword}{v}{%
\texttt{\textcolor{blue}{#1}}%
}
\usepackage{hyperref}

\title{CMSC838L - Final report}
\author{Arjun Vedantham \\ Yusuf Bham}
\date{May 2024}

\begin{document}

\maketitle

\section{Introduction and Motivation}
Digital signal processing techniques are extremely important in telecommunications, computer vision, and a number of other related fields.
In particular, digital signal processing techniques form a key component behind the idea of software defined radio (SDR),
which refers to analyzing digital samples that represent radio signals with software, instead of discrete hardware components that operate
over signals in analog formats. Software defined radio presents a notable improvement in flexibility for radio engineers, and removes the
need for specialized hardware components - instead, new signal demodulation techniques or formats can be deployed just through a simple software
update.

SDR users typically define signal processing pipelines using platforms like GNURadio. GNURadio presents a graphical format for creating these
pipelines, with discrete blocks representing a signal source, signal sink, or an intermediate step in the processing pipeline. As an example,
see the "flowgraph" (as called in GNURadio's documentation) below. This starts by instantiating a signal source from an RTL-SDR (a type of hobbyist SDR that can be used
over USB with consumer PCs), and sets both a sampling rate (32000 Hz) and a listening frequency (signals at 433 MHz). From here, these samples
are fed into a low pass filter block (which smooths out high frequency noise in the signal), and the resulting signal is transformed into
a stream that is passed to a GUI block that graphs the signal, using a Fast Fourier Transform (FFT) to move the signal into the frequency domain.

This simple flowgraph is stored in an XML format, and is used by GNURadio's backend to generate a Python script that actually runs the defined
processing pipeline. In addition, there are also C/C++ modules loaded into the runtime system for low level tasks - for instance, a USB driver for the SDR.

\subsection{Problems Identified with State of the Art}
There are number of problems with this current approach. First, GNURadio's practice of emitting Python scripts means that parallelism is
limited on two fronts - first, because of language design choices (Python's infamous "global interpreter lock", which essentially forbids
runtime concurrency), and also because we are ultimately running this script on standard PC hardware, which uses an inherently sequential
von Neumann architecture. Additionally, as previously mentioned, there is also an extensive library of C/C++ modules, and the implementation
of these modules are opaque to the Python-level code generated by GNURadio's flowgraph compiler.

As such, we identified two research questions that we aimed to answer in this project:

\begin{itemize}
    \item Could we use hardware acceleration to get better performance and greater parallelism for DSP applications?
    \item Could we design a language that is more conducive to defining correct DSP pipelines?
\end{itemize}

\section{Literature Review}
We started by conducting a literature review of existing languages designed for DSP problems.
\subsection{Ziria}
One of the first papers we considered as Ziria, a domain specific language that was
designed to aid development in implementations of the physical layer of wireless protocols.
Ziria presented a functional language design syntax, and was specifically intended for wireless protocol
implementations on IOT hardware. As such, it contained many primitives that we thought would
be important to add to our language - for instance, an "FFT" primitive function. However Ziria had a key limitation -
it was designed for standard CPUs, which meant that there were still parallelism limitations.

\subsection{Calyx}
One technique generally used for hardware acceleration for specialized applications like this
is to deploy them to FPGAs. One example of this was the Catapult paper that we read in class,
where Microsoft deployed FPGAs to accelerate running PageRank as part of their Bing server infrastructure.
However, FPGAs are notoriously difficult to program, and generally require extremely fine-grained circuit
configurations written in a hardware description language like Verilog.

Calyx is an intermediate representation for compilers developed by the CAPRA research group at Cornell.
It defines circuits in three distinct parts - a collection of memories (consisting of combinational memories/
flip-flops and registers), wire groups (which denote assignments between different memory components
in the circuit), and a statically defined control schedule that orders wire assignments.
Calyx has already been used in the Filament HDL, another domain specific language project from the CAPRA
group that incorporated signal timing into the language's type system.

\section{Technical Contribution}
We decided to use the Calyx IR and design a more general, hardware acceleratable language for DSP tasks, called Zinnia.
\footnote{Named "Zinnia" because "calyx" refers to the petals of a flower and zinnias are a type of flower. Plus it sounds like Ziria.}
We also considered emitting circuits using CIRCT, the LLVM framework that allows compilers to generate
MLIR that is subsequently lowered to a Verilog hardware description, however we quickly found that
CIRCT lacked the project maturity needed to develop even a basic language around it. This included
no binaries to link against, thus requiring us to compile a large subset of the LLVM project, which was not practical.
\end{document}
